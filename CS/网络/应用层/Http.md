### HTTP是什么?

从官方的定义来说：它是超文本传输协议，是一个简单的请求响应协议，是和HTML一起诞生的，最早是为了传输HTML，现在的话除了传输HTML还会用于传输JSON，也就是我们常说的接口。

### URL与HTTP报文的格式

URL由三部分组成，分别是协议类型，服务器地址/端口号，Path。

请求报文：
![[Pasted image 20250122145027.png]]

响应报文：
![[Pasted image 20250122145110.png]]
### 常用的请求方法

* GET：用于获取资源 对服务器数据不进行修改 不发送 Body

* POST：用于增加或修改资源，有Body

* PUT：用于修改资源，有Body

* DELETE：用于删除资源，无Body

* HEAD和GET 使用方法完全相同，和GET唯⼀区别在于，返回的响应中没有Body

### 常用Status Code 状态码

* 1xx：临时性消息。如：100 （继续发送）、101（正在切换协议）

* 2xx：成功。最典型的是 200（OK）、201（创建成功）

* 3xx：重定向。如 301（永久移动）、302（暂时移动）、304（内容未改变）

* 4xx：客户端错误。如 400（客户端请求错误）、401（认证失败）、403（被禁⽌）、 404（找不到内容）

* 5xx：服务器错误。如 500（服务器内部错误）。

### 什么是Header，常用的几种Header

简单来说Header就相当于一个Http传输的配置，我们在请求时的Body类型，Body长度等都是在Header中所定义的，常见的几种Header如下：

Ø  Host：目标主机。注意：不是在网络上用于寻址的，而是在目标服务器上用于定位子服务器的。

Ø  Content-Type 指定 Body 的类型。主要有四类：
* text/html： html文本
* x-www-form-urlencoded：表单的形式
* multipart/form-data：包含二进制文件的表单形式
* application/json：json文本

Ø  image/jpeg：单独的二进制文件

Ø  application/zip：单独的二进制文件

Ø  Content-Length：指定Body的长度（字节）。

Ø  Transfer: chunked：用于当响应发起时，内容⻓度还没能确定的情况下。和 Content-Length 不同时使用。用途是 尽早给出响应，减少用户等待。

Ø  Location：指定重定向的目标 URL

Ø  User-Agent：用户代理，就是是谁进行的发送接受，例如手机浏览器、某款手机App。

Ø  Range / Accept-Ranges 按范围取数据，作用：断点续传、多线程下载。

Accept-Ranges: bytes 响应报文中出现，表示服务器支持按字节来取范围数据

Range: bytes=start-end 请求报文中出现，表示要取哪段数据

Content-Range:start-end/total 响应报文中出现，表示发送的是哪段数据

Ø  Accept: 客户端能接受的数据类型。如 text/html

Ø  Accept-Charset：客户端接受的字符集。如 utf-8

Ø  Accept-Encoding：客户端接受的压缩编码类型。如 gzip

Ø  Content-Encoding：压缩类型。如 gzip

### Http和Https的区别

相对于http，https具有安全性，保证数据完整性等优点，代价是微乎其微的性能差异，因为涉及加密和解密操作。关于他的安全性，https通过SSL/TLS加密协议对传输的数据进行加密，即使数据被拦截，也无法查看传输的内容，从而保证数据的机密性。通过加密和MAC等机制确保数据在传输过程中未被篡改，接收方可以检测到是否被篡改。另外，某些搜索引擎会倾向于优先展示https的网站。

### Http1.1和Http2.0的区别

http1.1基于文本协议，每次请求和响应都是独立的文本交互，传输效率较低。

http2.0是二进制协议，并支持多路复用，使用二进制帧进行传输，提高了效率，具体就是将请求和响应分解为更小的消息，并通过一个连接进行并行处理。

除此之外http2支持首部压缩，大幅减少重复头部信息的传输，尤其是多次请求相同资源时，可以有效减少带宽。

2.0可以主动推送一些资源，通过多路复用和服务器推送，可以减少额外的握手和延迟。

### Https的加密过程

https加密过程主要通过两部分，加密和身份验证。

从客户端和服务端之间的TLS握手开始，客户端首先发送一个clienthello消息给服务器，消息中包含支持的TLS版本，支持的加密套件，一个用于生成加密秘钥的随机数，额外的扩展消息。服务端收到消息后回复一个serverhello消息，包括服务器选择的TLS版本和加密套件，生成的随机数，服务器的SSL/TLS证书。

客户端收到消息之后会验证证书是否有效，如果过期或不受信任将会终止连接，一旦客户端验证的服务器的证书，它将生成一个预主密钥，然后客户端使用服务器的公钥加密预主密钥并发给服务器，服务器收到加密的预主密钥后，使用自己的私钥解密它，然后客户端和服务器使用预主密钥和他们各自的随机数生成一组会话密钥，之后客户端和服务器都是用相同的会话密钥来加密和解密随后的所有通信数据，会话密钥采用对称加密算法，即同一个密钥用于加密和解密。

客户端想服务器发送finished消息表示他已完成握手过程，并且准备开始加密数据。

服务端也向客服端发送finished消息表示服务器也已完成握手，至此之间的通信已经建立的加密通道，后续的所有数据将通过对称加密的方式传输。